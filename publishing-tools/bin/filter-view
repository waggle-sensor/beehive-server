#!/usr/bin/env python3
import argparse
from datetime import datetime
import json
import csv
import sys


class Interval:

    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __contains__(self, dt):
        return ((self.start is None or self.start < dt) and
                (self.end is None or dt <= self.end))

    def __repr__(self):
        return repr((self.start, self.end))


datetime_format = '%Y/%m/%d %H:%M:%S'


def make_interval_list(events):
    intervals = []

    for event in sorted(events, key=lambda e: e['timestamp']):
        if event['event'] in ['commissioned']:
            start = event['timestamp']
            intervals.append(Interval(start, None))

        if event['event'] in ['decommissioned', 'retired']:
            end = event['timestamp']
            if len(intervals) > 0 and intervals[-1].end is None:
                intervals[-1].end = end

    return intervals


def convert_event_timestamps(node):
    if 'events' not in node:
        return

    for event in node['events']:
        event['timestamp'] = datetime.strptime(event['timestamp'], datetime_format)


def load_metadata_json(filename):
    with open(filename) as f:
        nodes = json.load(f)

    for node in nodes:
        convert_event_timestamps(node)

        # support for new commissioned tracking
        if 'events' in node:
            node['commissioned'] = make_interval_list(node['events'])
        # maintain support for old timestamp - will remove
        elif 'commissioned_at' in node:
            start = datetime.strptime(node['commissioned_at'], datetime_format)
            node['commissioned'] = [Interval(start, None)]

    return nodes


def load_nodes_metadata(filename):
    events = []

    with open(filename) as csvfile:
        reader = csv.reader(csvfile)

        for row in reader:
            try:
                lat = float(row[4])
                lon = float(row[5])
            except ValueError:
                continue

            events.append({
                'node_id': row[0],
                'project_id': row[1],
                'vsn': row[2],
                'address': row[3],
                'lat': lat,
                'lon': lon,
                'description': row[6],
            })

    return events


def load_timestamp(timestamp):
    return datetime.strptime(timestamp, '%Y/%m/%d %H:%M:%S')


def load_events_metadata(filename):
    events = []

    with open(filename) as csvfile:
        reader = csv.reader(csvfile)

        for row in reader:
            events.append({
                'node_id': row[0],
                'timestamp': load_timestamp(row[1]),
                'event': row[2],
                'comment': row[3],
            })

    return events


# just build filter instead??? then we can only include things which
# pass other info checks.
def join_metadata(nodes, events):
    nodes_by_id = {node['node_id']: node for node in nodes}

    for node in nodes:
        node['events'] = []

    for event in events:
        try:
            node = nodes_by_id[event['node_id']]
        except KeyError:
            continue

        node['events'].append(event)

    for node in nodes:
        node['commissioned'] = make_interval_list(node['events'])

    return nodes


import pprint


def read_metadata(basepath):
    nodes = load_nodes_metadata(basepath + '/nodes.csv')
    events = load_events_metadata(basepath + '/events.csv')

    nodes = join_metadata(nodes, events)

    pprint.pprint(nodes)


read_metadata('../examples/plenario')

# if __name__ == '__main__':
#     parser = argparse.ArgumentParser()
#     parser.add_argument('meta', help='metadata config file for view')
#     args = parser.parse_args()
#
#     nodes = read_metadata(args.meta)
#     nodes_by_id = {node['node_id']: node for node in nodes}
#
#     def isviewable(line):
#         fields = line.split(';')
#         node_id = fields[0]
#         timestamp = datetime.strptime(fields[1], datetime_format)
#
#         if node_id not in nodes_by_id:
#             return False
#
#         node = nodes_by_id[node_id]
#
#         return any(timestamp in interval for interval in node['commissioned'])
#
#     for line in filter(isviewable, sys.stdin.readlines()):
#         sys.stdout.write(line)
