#!/usr/bin/env python3
import argparse
from cassandra.cluster import Cluster
import csv
import datetime
import pika
import sys
import waggle.protocol


cluster = Cluster(['beehive-cassandra'])
session = cluster.connect('waggle')

session.execute('''
CREATE TABLE IF NOT EXISTS waggle.measurements_by_date (
  date date,
  timestamp timestamp,
  node_id text,
  subsystem text,
  sensor text,
  parameter text,
  value text,
  PRIMARY KEY ((node_id, date), timestamp, subsystem, sensor, parameter)
)
''')

measurements_by_date = session.prepare('''
INSERT INTO measurements_by_date
(date, timestamp, node_id, subsystem, sensor, parameter, value)
VALUES (?, ?, ?, ?, ?, ?, ?)
''')

session.execute('''
CREATE TABLE IF NOT EXISTS waggle.measurements_by_type (
  timestamp timestamp,
  node_id text,
  subsystem text,
  sensor text,
  parameter text,
  value text,
  PRIMARY KEY ((node_id, subsystem, sensor, parameter), timestamp)
)
''')

measurements_by_type = session.prepare('''
INSERT INTO measurements_by_type
(node_id, subsystem, sensor, parameter, timestamp, value)
VALUES (?, ?, ?, ?, ?, ?)
''')


def stringify_value(value):
    if isinstance(value, bytes):
        return value.hex()
    if isinstance(value, list):
        return ','.join(map(str, value))
    return repr(str(value))


def unpack_messages_and_sensorgrams(body):
    for message in waggle.protocol.unpack_waggle_packets(body):
        for datagram in waggle.protocol.unpack_datagrams(message['body']):
            for sensorgram in waggle.protocol.unpack_sensorgrams(datagram['body']):
                yield message, datagram, sensorgram


csvout = csv.writer(sys.stdout)


def message_handler(ch, method, properties, body):
    for message, datagram, sensorgram in unpack_messages_and_sensorgrams(body):
        ts = datetime.datetime.fromtimestamp(sensorgram['timestamp'])
        node_id = message['sender_id']
        subsystem = message['sender_sub_id']
        sensor = str(sensorgram['sensor_id'])
        parameter = str(sensorgram['parameter_id'])
        value = stringify_value(sensorgram['value'])

        session.execute(
            measurements_by_date,
            (ts.date(), ts, node_id, subsystem, sensor, parameter, value))

        session.execute(
            measurements_by_type,
            (node_id, subsystem, sensor, parameter, ts, value))

        csvout.writerow([
            ts,
            node_id,
            subsystem,
            sensor,
            parameter,
            value,
        ])

        sys.stdout.flush()

    ch.basic_ack(delivery_tag=method.delivery_tag)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--url', default='amqp://localhost')
    parser.add_argument('node_id')
    args = parser.parse_args()

    queue = 'to-node-{}'.format(args.node_id)

    connection = pika.BlockingConnection(pika.URLParameters(args.url))
    channel = connection.channel()

    channel.queue_declare(queue=queue, durable=True)
    channel.basic_consume(message_handler, queue)
    channel.start_consuming()


if __name__ == '__main__':
    main()
